<html>
  <head>
    <title>WebGPU triangle texture example</title>
    <style>
      body {
        margin: 0;
        background-color: #000;
        color: #fff;
        overscroll-behavior: none;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import glslangModule from './js/glslang.js';
      import { mat4 } from './js/glmatrix.js';

      // @TODO: Detect WebGPU capability

      const run = async () => {
        const glslang = await glslangModule();

        const vertexShaderCode = `#version 450
          layout(set=0, binding=0) uniform Uniforms {
            mat4 modelMatrix;
          } uniforms;

          layout(location = 0) in vec3 position;
          layout(location = 1) in vec2 uv;

          layout(location = 0) out vec2 fragUv;

          void main() {
            gl_Position = uniforms.modelMatrix * vec4(position, 1.0);
            fragUv = uv;
          }
        `;

        const fragmentShaderCode = `#version 450
          layout(set=0, binding=1) uniform sampler testSampler;
          layout(set=0, binding=2) uniform texture2D testTexture;
          layout(location = 0) in vec2 fragUv;
          layout(location = 0) out vec4 outColor;

          void main() {
            outColor = texture(sampler2D(testTexture, testSampler), fragUv);
          }
        `;

        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const context = canvas.getContext('gpupresent');
        const format = 'bgra8unorm'
        const swapChain = context.configureSwapChain({
          device,
          format
        });

        const vertexBuffer = device.createBuffer({
          size: 4 * 15, // float32 (vec3, vec2) x 3
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
        });

        vertexBuffer.setSubData(0, new Float32Array([
          // position: vec3, uv: vec2
          -0.5, -0.5, 0.0, 0.0, 0.0,
          0.5, -0.5, 0.0, 1.0, 0.0,
          0.5, 0.5, 0.0, 1.0, 1.0
        ]));

        const uniformsBindGroupLayout = device.createBindGroupLayout({
          bindings: [{
            binding: 0,
            visibility: GPUShaderStage.VERTEX,
            type: 'uniform-buffer'
          }, {
            binding: 1,
            visibility: GPUShaderStage.FRAGMENT,
            type: 'sampler'
          }, {
            binding: 2,
            visibility: GPUShaderStage.FRAGMENT,
            type: 'sampled-texture'
          }]
        });

        const textureWidth = 64;
        const textureHeight = 64;

        const dataTexture = device.createTexture({
          size: {
            width: textureWidth,
            height: textureHeight,
            depth: 1
          },
          format: 'rgba8unorm',
          usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST
        });

        const textureDataBuffer = device.createBuffer({
          size: textureWidth * textureHeight * 4,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });

        const data = new Uint8Array(textureWidth * textureHeight * 4);
        for (let i = 0; i < textureWidth * textureHeight; i++) {
          const baseIndex = i * 4;
          data[baseIndex + 0] = Math.floor(Math.random() * 256);
          data[baseIndex + 1] = Math.floor(Math.random() * 256);
          data[baseIndex + 2] = Math.floor(Math.random() * 256);
          data[baseIndex + 3] = 255;
        }

        textureDataBuffer.setSubData(0, data);

        const textureCommandEncoder = device.createCommandEncoder({});
        textureCommandEncoder.copyBufferToTexture({
          buffer: textureDataBuffer,
          rowPitch: textureWidth * 4,
          imageHeight: 0
        }, {
          texture: dataTexture
        }, {
          width: textureWidth,
          height: textureHeight,
          depth: 1
        });

        device.defaultQueue.submit([textureCommandEncoder.finish()]);

        const modelMatrix = mat4.identity(mat4.create());

        const sampleCount = 4;

        const uniformBuffer = device.createBuffer({
          size: 4 * 16, // 4x4 float32 matrix
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const sampler = device.createSampler({
          magFilter: 'linear',
          minFilter: 'linear'
        });

        const uniformBindGroup = device.createBindGroup({
          layout: uniformsBindGroupLayout,
          bindings: [{
            binding: 0,
            resource: {
              buffer: uniformBuffer
            }
          }, {
            binding: 1,
            resource: sampler
          }, {
            binding: 2,
            resource: dataTexture.createView()
          }]
        });

        const pipeline = device.createRenderPipeline({
          layout: device.createPipelineLayout({bindGroupLayouts: [uniformsBindGroupLayout]}),
          vertexStage: {
            module: device.createShaderModule({
              code: glslang.compileGLSL(vertexShaderCode, 'vertex'),
              source: vertexShaderCode,
              transform: source => glslang.compileGLSL(source, 'vertex')
            }),
            entryPoint: 'main'
          },
          fragmentStage: {
            module: device.createShaderModule({
              code: glslang.compileGLSL(fragmentShaderCode, 'fragment'),
              source: fragmentShaderCode,
              transform: source => glslang.compileGLSL(source, 'fragment')
            }),
            entryPoint: 'main'
          },
          primitiveTopology: 'triangle-list',
          vertexState: {
            vertexBuffers: [{
              arrayStride: 4 * 5,
              attributes: [{
                shaderLocation: 0,
                offset: 0,
                format: 'float4'
              }, {
                shaderLocation: 1,
                offset: 4 * 3,
                format: 'float2'
              }]
            }]
          },
          colorStates: [{
            format
          }],
          sampleCount
        });

        const texture = device.createTexture({
          size: {
            width: Math.floor(window.innerWidth * window.devicePixelRatio),
            height: Math.floor(window.innerHeight * window.devicePixelRatio),
            depth: 1
          },
          sampleCount,
          format,
          usage: GPUTextureUsage.OUTPUT_ATTACHMENT
        });

        const attachment = texture.createView();

        let rotation = 0;

        const frame = () => {
          requestAnimationFrame(frame);
          rotate(modelMatrix);
          uniformBuffer.setSubData(0, modelMatrix);
          const commandEncoder = device.createCommandEncoder({});
          const renderPassDescriptor = {
            colorAttachments: [{
              attachment: attachment,
              resolveTarget: swapChain.getCurrentTexture().createView(),
              loadValue: {r: 0.0, g: 0.0, b: 0.0, a: 1.0}
            }]
          };
          const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
          passEncoder.setPipeline(pipeline);
          passEncoder.setVertexBuffer(0, vertexBuffer);
          passEncoder.setBindGroup(0, uniformBindGroup);
          passEncoder.draw(3, 1, 0, 0);
          passEncoder.endPass();
          device.defaultQueue.submit([commandEncoder.finish()]);
        };

        const rotate = matrix => {
          mat4.fromZRotation(matrix, rotation * Math.PI / 180);
          rotation++;
          return matrix;
        };

        const onResize = event => {
          const width = window.innerWidth;
          const height = window.innerHeight;
          canvas.width = Math.floor(window.innerWidth * window.devicePixelRatio);
          canvas.height = Math.floor(window.innerHeight * window.devicePixelRatio);
          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
        };

        window.addEventListener('resize', onResize, false);

        onResize();
        frame();
      };

      run();
    </script>
  </body>
</html>